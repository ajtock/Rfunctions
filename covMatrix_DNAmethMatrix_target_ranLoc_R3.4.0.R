# Function to create coverage matrices for feature loci and random loci (incl. flanking regions)
## and to calculate mean levels per window
covMatrix <- function(signal,
                      feature,
                      ranLoc,
                      featureSize,
                      flankSize,
                      winSize,
                      outDF,
                      outDFcolMeans) {
  # feature loci
  set.seed(2840)
  feature_smoothed <- normalizeToMatrix(signal = signal,
                                        target = feature,
                                        value_column = "coverage",
                                        extend = flankSize,
                                        mean_mode = "w0",
                                        w = winSize,
                                        background = 0,
                                        smooth = TRUE,
                                        include_target = TRUE,
                                        target_ratio = featureSize/(featureSize+(flankSize*2)))
  print("feature_smoothed")
  print(feature_smoothed)
  print("feature_smoothed rows = ")
  print(length(feature_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  feature_smoothed_DF <- data.frame(feature_smoothed)
  feature_smoothed_DF_colMeans <- as.vector(colMeans(feature_smoothed_DF,
                                                     na.rm = T))
  write.table(feature_smoothed_DF,
              file = outDF[[1]],
              quote = F, sep = "\t", row.names = F, col.names = T)
  write.table(feature_smoothed_DF_colMeans,
              file = outDFcolMeans[[1]],
              quote = F, sep = "\t", row.names = F, col.names = T)

  # random loci
  set.seed(8472)
  ranLoc_smoothed <- normalizeToMatrix(signal = signal,
                                       target = ranLoc,
                                       value_column = "coverage",
                                       extend = flankSize,
                                       mean_mode = "w0",
                                       w = winSize,
                                       background = 0,
                                       smooth = TRUE,
                                       include_target = TRUE,
                                       target_ratio = featureSize/(featureSize+(flankSize*2)))
  print("ranLoc_smoothed")
  print(ranLoc_smoothed)
  print("ranLoc_smoothed rows = ")
  print(length(ranLoc_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ranLoc_smoothed_DF <- data.frame(ranLoc_smoothed)
  ranLoc_smoothed_DF_colMeans <- as.vector(colMeans(ranLoc_smoothed_DF,
                                                    na.rm = T))
  write.table(ranLoc_smoothed_DF,
              file = outDF[[2]],
              quote = F, sep = "\t", row.names = F, col.names = T)
  write.table(ranLoc_smoothed_DF_colMeans,
              file = outDFcolMeans[[2]],
              quote = F, sep = "\t", row.names = F, col.names = T)
}

# R3.4.0 or R3.5.0: EnrichedHeatmap guide says normalizeToMatrix() background = NA
# for DNA methylation data. However, this generates incorrect methylation profiles.
# Profiles are improved when background = 0 but the methylation proportion values
# are not consistent with those generated by previous versions of EnrichedHeatmap
# (e.g., in R3.3.2 - see DNAmethMatrix() function below)
# Function to create DNA methylation matrices for feature loci and random loci (incl. flanking regions)
## and to calculate mean levels per window
DNAmethMatrixBroken <- function(signal,
                                feature,
                                ranLoc,
                                featureSize,
                                flankSize,
                                winSize,
                                DNAmethOutDF,
                                DNAmethOutDFcolMeans) {
  # feature loci
  set.seed(2840)
  feature_smoothed <- normalizeToMatrix(signal = signal,
                                        target = feature,
                                        value_column = "coverage",
                                        extend = flankSize,
                                        mean_mode = "absolute",
                                        w = winSize,
                                        background = 0,
                                        smooth = TRUE,
                                        include_target = TRUE,
                                        target_ratio = featureSize/(featureSize+(flankSize*2)))
  print("feature_smoothed")
  print(feature_smoothed)
  print("feature_smoothed rows = ")
  print(length(feature_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  feature_smoothed_failed_rows <- attr(feature_smoothed, "failed_rows")
  print("feature_smoothed failed rows = ")
  print(length(feature_smoothed_failed_rows))
  ## Below code chunk should be commented out to retain complete matrices for
  ## heatmap row ordering
  #if(is.null(feature_smoothed_failed_rows) == FALSE) {
  #  feature_smoothed <- feature_smoothed[-feature_smoothed_failed_rows,]
  #}
  #print("feature_smoothed rows less failed rows = ")
  #print(length(feature_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ##
  feature_smoothed_DF <- data.frame(feature_smoothed)
  feature_smoothed_DF_colMeans <- as.vector(colMeans(feature_smoothed_DF,
                                                     na.rm = T))
  write.table(feature_smoothed_DF,
              file = DNAmethOutDF[[1]],
              quote = F, sep = "\t", row.names = F, col.names = T)
  write.table(feature_smoothed_DF_colMeans,
              file = DNAmethOutDFcolMeans[[1]],
              quote = F, sep = "\t", row.names = F, col.names = T)

  # random loci
  set.seed(8472)
  ranLoc_smoothed <- normalizeToMatrix(signal = signal,
                                       target = ranLoc,
                                       value_column = "coverage",
                                       extend = flankSize,
                                       mean_mode = "absolute",
                                       w = winSize,
                                       background = 0,
                                       smooth = TRUE,
                                       include_target = TRUE,
                                       target_ratio = featureSize/(featureSize+(flankSize*2)))
  print("ranLoc_smoothed")
  print(ranLoc_smoothed)
  print("ranLoc_smoothed rows = ")
  print(length(ranLoc_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ranLoc_smoothed_failed_rows <- attr(ranLoc_smoothed, "failed_rows")
  print("ranLoc_smoothed failed rows = ")
  print(length(ranLoc_smoothed_failed_rows))
  ## Below code chunk should be commented out to retain complete matrices for
  ## heatmap row ordering
  #if(is.null(ranLoc_smoothed_failed_rows) == FALSE) {
  #  ranLoc_smoothed <- ranLoc_smoothed[-ranLoc_smoothed_failed_rows,]
  #}
  #print("ranLoc_smoothed rows less failed rows = ")
  #print(length(ranLoc_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ##
  ranLoc_smoothed_DF <- data.frame(ranLoc_smoothed)
  ranLoc_smoothed_DF_colMeans <- as.vector(colMeans(ranLoc_smoothed_DF,
                                                    na.rm = T))
  write.table(ranLoc_smoothed_DF,
              file = DNAmethOutDF[[2]],
              quote = F, sep = "\t", row.names = F, col.names = T)
  write.table(ranLoc_smoothed_DF_colMeans,
              file = DNAmethOutDFcolMeans[[2]],
              quote = F, sep = "\t", row.names = F, col.names = T)
}

# R3.3.2: use now deprecated empty_value = NA (as opposed to background = NA in >= R3.4.0)
# Function to create DNA methylation matrices for feature loci and random loci (incl. flanking regions)
## and to calculate mean levels per window
DNAmethMatrix <- function(signal,
                          feature,
                          ranLoc,
                          featureSize,
                          flankSize,
                          winSize,
                          DNAmethOutDF,
                          DNAmethOutDFcolMeans) {
  # feature loci
  set.seed(2840)
  feature_smoothed <- normalizeToMatrix(signal = signal,
                                        target = feature,
                                        value_column = "coverage",
                                        extend = flankSize,
                                        mean_mode = "absolute",
                                        w = winSize,
                                        empty_value = NA,
                                        smooth = TRUE,
                                        include_target = TRUE,
                                        target_ratio = featureSize/(featureSize+(flankSize*2)))
  print("feature_smoothed")
  print(feature_smoothed)
  print("feature_smoothed rows = ")
  print(length(feature_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  feature_smoothed_failed_rows <- attr(feature_smoothed, "failed_rows")
  print("feature_smoothed failed rows = ")
  print(length(feature_smoothed_failed_rows))
  ## Below code chunk should be commented out to retain complete matrices for
  ## heatmap row ordering
  #if(is.null(feature_smoothed_failed_rows) == FALSE) {
  #  feature_smoothed <- feature_smoothed[-feature_smoothed_failed_rows,]
  #}
  #print("feature_smoothed rows less failed rows = ")
  #print(length(feature_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ##
  feature_smoothed_DF <- data.frame(feature_smoothed)
  feature_smoothed_DF_colMeans <- as.vector(colMeans(feature_smoothed_DF,
                                                     na.rm = T))
  write.table(feature_smoothed_DF,
              file = DNAmethOutDF[[1]],
              quote = F, sep = "\t", row.names = F, col.names = T)
  write.table(feature_smoothed_DF_colMeans,
              file = DNAmethOutDFcolMeans[[1]],
              quote = F, sep = "\t", row.names = F, col.names = T)

  # random loci
  set.seed(8472)
  ranLoc_smoothed <- normalizeToMatrix(signal = signal,
                                       target = ranLoc,
                                       value_column = "coverage",
                                       extend = flankSize,
                                       mean_mode = "absolute",
                                       w = winSize,
                                       empty_value = NA,
                                       smooth = TRUE,
                                       include_target = TRUE,
                                       target_ratio = featureSize/(featureSize+(flankSize*2)))
  print("ranLoc_smoothed")
  print(ranLoc_smoothed)
  print("ranLoc_smoothed rows = ")
  print(length(ranLoc_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ranLoc_smoothed_failed_rows <- attr(ranLoc_smoothed, "failed_rows")
  print("ranLoc_smoothed failed rows = ")
  print(length(ranLoc_smoothed_failed_rows))
  ## Below code chunk should be commented out to retain complete matrices for
  ## heatmap row ordering
  #if(is.null(ranLoc_smoothed_failed_rows) == FALSE) {
  #  ranLoc_smoothed <- ranLoc_smoothed[-ranLoc_smoothed_failed_rows,]
  #}
  #print("ranLoc_smoothed rows less failed rows = ")
  #print(length(ranLoc_smoothed)/round((featureSize/winSize)+((flankSize*2)/winSize)))
  ##
  ranLoc_smoothed_DF <- data.frame(ranLoc_smoothed)
  ranLoc_smoothed_DF_colMeans <- as.vector(colMeans(ranLoc_smoothed_DF,
                                                    na.rm = T))
  write.table(ranLoc_smoothed_DF,
              file = DNAmethOutDF[[2]],
              quote = F, sep = "\t", row.names = F, col.names = T)
  write.table(ranLoc_smoothed_DF_colMeans,
              file = DNAmethOutDFcolMeans[[2]],
              quote = F, sep = "\t", row.names = F, col.names = T)
}
